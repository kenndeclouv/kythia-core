/**
 * üßô‚Äç‚ôÇÔ∏è The Type Wizard (Smart Index-Reader)
 *
 * @file src/cli/commands/DIGenerateCommand.ts
 * @copyright ¬© 2025 kenndeclouv
 * @version 0.12.3-beta
 *
 * @description
 * 1. Reads index.js using AST to find which helpers are ACTUALLY injected.
 * 2. Scans filesystem for Models & Helpers.
 * 3. Generates types ONLY for the injected helpers.
 */

import Command from '../Command';
import fs from 'node:fs';
import path from 'node:path';
import { glob } from 'glob';
import * as parser from '@babel/parser';
import traverse from '@babel/traverse';

export default class DIGenerateCommand extends Command {
	public signature = 'di:generate';
	public description = 'Generate types by analyzing index.js dependencies.';

	public async handle(): Promise<void> {
		const PROJECT_ROOT = process.cwd();
		const OUTPUT_DIR = path.join(PROJECT_ROOT, 'types');
		const OUTPUT_FILE = path.join(OUTPUT_DIR, 'auto-di.d.ts');
		const INDEX_FILE = path.join(PROJECT_ROOT, 'index.js');

		console.log('--- üßô‚Äç‚ôÇÔ∏è Kythia Type Wizard (Smart Mode) ---');

		console.log('üìñ Reading index.js to find injected helpers...');
		const injectedHelpers = new Set<string>();

		try {
			const indexCode = fs.readFileSync(INDEX_FILE, 'utf8');
			const ast = parser.parse(indexCode, {
				sourceType: 'module',
				plugins: ['typescript', 'objectRestSpread'],
				errorRecovery: true,
			});

			traverse(ast, {
				VariableDeclarator(path) {
					if (
						path.node.id.type === 'Identifier' &&
						path.node.id.name === 'dependencies'
					) {
						const init = path.node.init;
						if (init && init.type === 'ObjectExpression') {
							const helpersProp = init.properties.find(
								(p: any) => p.key.name === 'helpers',
							) as any;

							if (
								helpersProp &&
								helpersProp.value.type === 'ObjectExpression'
							) {
								helpersProp.value.properties.forEach((p: any) => {
									if (p.key?.name) {
										injectedHelpers.add(p.key.name);
									}
								});
							}
						}
					}
				},
			});
		} catch (_e) {
			console.warn(
				'‚ö†Ô∏è Failed to parse index.js. Generating all helpers as fallback.',
			);
		}

		console.log(
			`   > Detected keys: \x1b[36m${Array.from(injectedHelpers).join(', ')}\x1b[0m`,
		);

		const models: Record<string, string> = {};
		const helpers: Record<string, string> = {};

		const toAliasPath = (filePath: string) => {
			const normalized = filePath.split(path.sep).join('/');
			if (normalized.includes('/addons/'))
				return `@addons/${normalized.split('/addons/')[1].replace(/\.(js|ts)$/, '')}`;
			if (normalized.includes('/src/'))
				return `@src/${normalized.split('/src/')[1].replace(/\.(js|ts)$/, '')}`;
			return null;
		};

		glob
			.sync('{src,addons/**}/models/*.{js,ts}', {
				cwd: PROJECT_ROOT,
				ignore: ['**/*.d.ts'],
			})
			.forEach((file) => {
				const name = path.basename(file, path.extname(file));
				const alias = toAliasPath(path.join(PROJECT_ROOT, file));
				if (alias) models[name] = alias;
			});

		glob
			.sync('{src,addons/**}/helpers/*.{js,ts}', {
				cwd: PROJECT_ROOT,
				ignore: ['**/*.d.ts'],
			})
			.forEach((file) => {
				const name = path.basename(file, path.extname(file));

				if (injectedHelpers.size > 0 && !injectedHelpers.has(name)) return;

				const alias = toAliasPath(path.join(PROJECT_ROOT, file));
				if (alias) helpers[name] = alias;
			});

		const lines = [
			'// üõë DO NOT EDIT. Auto-generated by "bunx kythia di:generate"',
			'// üßô‚Äç‚ôÇÔ∏è The Type Wizard - Smart Mode',
			'',
			'declare global {',
			'    namespace KythiaDI {',
			'        interface Container {',
			'            // --- Core Services ---',
			'            client: import("discord.js").Client;',
			'            sequelize: import("sequelize").Sequelize;',
			'            redis: import("ioredis").default;',
			'            kythiaConfig: any;',
			'            t: (interaction: any, key: string, args?: any) => Promise<string>;',
			'',
			'            // --- Models ---',
			'            models: {',
		];

		Object.entries(models)
			.sort()
			.forEach(([name, importPath]) => {
				lines.push(`                ${name}: typeof import('${importPath}');`);
			});

		lines.push('            };');
		lines.push('            // --- Helpers (Injected in index.js) ---');
		lines.push('            helpers: {');
		lines.push(
			'                discord: typeof import("@coreHelpers/discord");',
		);

		if (injectedHelpers.has('color')) {
			lines.push(
				'                color: { convertColor: (color: any, opts?: any) => number };',
			);
		}

		Object.entries(helpers)
			.sort()
			.forEach(([name, importPath]) => {
				if (name === 'discord') return;
				lines.push(`                ${name}: typeof import('${importPath}');`);
			});

		lines.push('            };');
		lines.push('        }');
		lines.push('    }');
		lines.push('}');

		if (!fs.existsSync(OUTPUT_DIR))
			fs.mkdirSync(OUTPUT_DIR, { recursive: true });
		fs.writeFileSync(OUTPUT_FILE, lines.join('\n'));

		console.log(
			`\n\x1b[32m‚ú® Done! Generated types matching your index.js dependencies.\x1b[0m`,
		);
	}
}
